use std::io;use std::fmt;use std::fmt::Formatter;enum Et { V, B, P,}struct Le { et: Et, id: usize, cd: Vec<Le>,}impl fmt::Display for Le { fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result { match self.et { Et::V => write!(f, "{}", self.id as u8 as char), Et::P => write!(f, "({})({})", self.cd[0], self.cd[1]), Et::B => write!(f, "λ{}.{}", self.id as u8 as char, self.cd[0]) } }}fn s(e: &mut Le, f: usize, t: Le) { if e.id == f { if e.et == Et::V { e.et = t.et; e.id = t.id; e.cd = t.cd; } else if e.et == Et::B { e.id += 1; s(e, f, Le { et: Et::V, id: f + 1, cd: vec![], }); } } else { for c in &mut e.cd { s(c, f, t.clone()); } }}fn bs(expr: &mut Le) -> bool { if expr.et == Et::P && expr.cd[0].et == Et::B { expr.et = expr.cd[0].cd[0].et.clone(); expr.id = expr.cd[0].cd[0].id; let from_tmp = expr.cd[0].id; let to_tmp = expr.cd[1].clone(); expr.cd = expr.cd[0].cd[0].cd.clone(); s(expr, from_tmp, to_tmp); true } else { let mut found_redex = false; for child in &mut expr.cd { found_redex |= bs(child); } found_redex }}fn b(expr: &mut Le) { while bs(expr) {}}fn ie(i: String) -> Le { if i.len() == 1 { Le { et: Et::V, id: i.chars().nth(0).unwrap() as usize, cd: vec![], } } else if i.chars().nth(0).unwrap() == 'λ' { let mut c = i.chars(); Le { et: Et::B, id: c.nth(1).unwrap() as usize, cd: vec![ ie(c.skip(1).take_while(|_| true).collect()) ] } } else { let c = i.chars(); let d = c.clone().scan(0, |acc, x| if x == '(' {*acc += 1; Some(*acc)} else if x == ')' {*acc -= 1; Some(*acc)} else {Some(*acc)}); let a = c.clone().zip(d.clone()).skip(1).take_while(|x| x.1 != 0).map(|x| x.0).collect(); let mut b = c.zip(d.clone()).skip(1).skip_while(|x| x.1 != 0).skip(1).take_while(|_| true).map(|x| x.0).collect::<String>(); b.pop(); b.remove(0); Le { et: Et::P, id: 0, cd: vec![ ie(a), ie(b) ] } }}fn main() { let mut i = String::new(); io::stdin().read_line(&mut i).unwrap(); let mut e = ie(String::from(i.trim())); println!("{:?}", e); b(&mut e); println!("{}", e);}